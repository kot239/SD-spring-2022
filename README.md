# SD-spring-2022

## Task 1

Сделали:

* Гордеева Татьяна
* Обрядина Александра
* Тарабонда Герман

![Схема архитектуры](https://github.com/kot239/SD-spring-2022/blob/task-1/CLIArchitecture.png)

Далее будут описаны классы, их поля и методы, которые будут использоваться в программе

## Memory 

### Описание 

`Memory` – класс, созданный для хранения переменных окружения. Заметим, что есть еще некоторые системные переменные окружения, например `$HOME`, которые «заранее» присвоены в любой сессии работы терминала. Поэтому в `Memory` сначала нужно загрузить их.

### Поля

*  `Map<String, String> storage` – ключом является имя переменной окружения, а значением – ее значение

### Методы

* `String get(String key)` – получение значение переменной по ключу.

* `void put(String key, String value)` – добавление в storage новой переменной окружения

* `void putAll(Map<String, String> m)` – добавление нескольких ключей за раз. Нужно для случая, который описывается дальше.



## Main

### Описание

В Main читаются входные строки и передаются в Executor.

## Executor

### Описание

Executor отвечает за основную логику работы. Он передает входные строки парсеру, который возвращает синтаксическое дерево. Затем выполняет синтаксическое дерево по алгоритму, указанному ниже

### Поля

* `Parser parser` Парсер, который преобразует строку в синтаксическое дерево
* `Memory memory` Используемая память
* `InputStream inputStream` Текущий поток данных
* `List<Command> commands` Текущий список команд и аргументов

### Методы

* `void execute(String input)` Выполняет команды, указанные в `input`, которые были переданы в командную строку.

### Алгоритм выполнения execute

1. `input` передается парсеру, который выдает синтаксическое дерево
2. Выполняет команды синтаксического дерево согласно обходу в глубину. Обходим детей вершин в порядке слева направо.
3. Выполняем задание в вершине, согласно ее типу (вызываем функцию `do()` у вершины):
  * Если ее тип `V`, то делаем подстановку переменных
  * Если ее тип `C`, то выполняем команду, с текущим потоком, а затем полученный поток кладем в текущий поток

## Parser

### Описание

У нас есть несколько важных случаев работы: 

1) В одинарных кавычках подстановка переменных не происходит
```console
% echo '$HOME'
$HOME
```

2) В двойных кавычках подставнока переменных происходит
```console
% echo "$HOME"
/Users/xbreathoflife
```

3) Если двойные кавычки внутри одинарных, то подстановка не произойдет
```console
% echo '"$HOME"'
"$HOME"
```

4) Если одинарные кавычки внутри двойных, то подстановка произойдет
```console
% echo "'$HOME'"
'/Users/xbreathoflife'
```

Поэтому нам нужно разбить нашу строку на элементы, подстроки.

* Все, что внутри кавычек, является одним элементом. Например, `"''$HOME''"` или `'""$HOME""'`. Причем важно знать, для каких элементов должна быть выполнена подстановка переменной, а для каких - нет. В примере выше для первого элемента выполнится подстановка, а для второго - нет.

* (Так как экранирование пока не поддержано, то одна одинарная кавычка не может являться подстрокой)

* Пробел не является элементом.

* Пайп (`|`) является элементом.

В результате получаем список подстрок. Причем часть из них помечена, что в них подстановка не требуется, другие же помечены, что требуется. Будем подставлять, пока не получим такой список, в котором никому подстановка не требуется. Причем заметим, что если строка отмечена, что подстановка требуется, но в ней нету знака `$`, то можем считать, что не требуется.

Именем переменной при подстановки считается все от символа `$` до символов `'`, `$`, `"` или конец подстроки.

После соединяем полученные подстроки и отдаем парсеру, чтобы он разбил строку на команды. 

### Алгоритм

Сначла проверяем на кратность кавычек. Если одинарных или двойных кавычек нечетное количество, то кидаем ошибку.

Создаем дерево прохода, которое будет выполняться. Перед началом алгоритма у нас есть только одна вершина -- корень.

### Поля

* `Tree tree` строящееся синатксическое дерево
* `List<String> tokens` список токенов

### Методы

* `Tree parse()` возвращает синтаксическое дерево, которое будет выполняться

1. Делим строку на токены. Если начали с `$(`, то наш токен должен закончиться `)`, иначе токен должен закончиться пробелом. Отдельный токен -- символ `|`. Если мы встретили `"`, то ищем ближайшие справа двойные кавычки и все что внутри заключаем в единый токен с типом `U`. Если встретили `'`, то ищем ближайшие справа одинарные кавычки и все что внутри заключаем в единый токен с типом `T`.
2. Если наши токены содержат `|`, то создаем детей у вершины, которые содержат все токены, разделенные `|`. Тип этой вершины -- `C`.
3. Если наш токен `U`, то делаем нашей вершине ребенка и делим так же, как и в первом пункте, только не вешаем токен с типом `T`
4. Если токен содержит `$`, то делаем для этого токена отдельную вершину типа `V`.
5. Если токен содержит `=`, то делаем для этого токена отдельную вершину типа `Eq`.

## Tree

### Описание

Создает синтаксическое дерево. Передается `Executer` для прохода по дереву

## Node

### Описание

Вершина синтаксического дерева.

### Поля

* `NodeType type` один из типов вершин
  * `V` подстановка переменных
  * `Eq` запись переменных
  * `C` выполнение команды
* `List<String> args` список аршументов

### Методы

`void do()` -- делаем то, что должна делать вершина (описано в Executer)

## Command

### Описание

У нас есть общий интерфейс `AbstractCommand`, в котором есть следующие поля:

### Поля

* `String command` - имя комманды

* `InputStream inputStream` - поток ввода, из него читаем

* `OutputStream outputStream` - поток вывода, в него пишем

### Методы

* `ReturnCode execute()` - запрос на выполнения `command`. В зависимости от результата выполнения вернет `ReturnCode`, что все хорошо или плохо.

Команды, которые описаны далее, наследуются от этого интерфейса.

### CatCommand

Есть дополнительное поле:

`List<String> args`

Должно быть передано не более одного аргумента. Если один, то в поток вывода будет записано содержимое файла.

Если аргументов больше - ошибка.

Если аргументов нет, то содержимое `inputStream` будет записано  в `outputStream`.

### EchoCommand

Есть дополнительное поле:

`List<String> args`

Записывает в поток вывода переданные аргументы, разделенные пробелом.


### WcCommand

Есть дополнительное поле:

`List<String> args`

Выводит в поток вывода количество строк, слов и байт в файле для каждого переданного аргумента. Новая строка на каждый аргумент.

Если аргументов нет, то берет данные из потока чтения.

### PwdCommand

Нет аргументов.

Выводит путь к текущей директории в поток вывода.

### ExitCommand

Вызывает у основого класса метод `exit()`, тем самым завершая чтение команд в бесконечном цикле.

### OtherCommand

Есть дополнительное поле:

`List<String> args`

Вызывает внешнюю программу с переданными аргументами. Вывод записывается в поток вывода.
