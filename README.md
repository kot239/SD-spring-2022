# SD-spring-2022

## Task 1

Сделали:

* Гордеева Татьяна
* Обрядина Александра
* Тарабонда Герман


## Memory 

`Memory` – класс, созданный для хранения переменных окружения. В нем должно быть следующее поле: 

*  `Map<String, String> storage` – ключом является имя переменной окружения, а значением – ее значение

И следующие методы:

* `String get(String key)` – получение значение переменной по ключу.

* `void put(String key, String value)` – добавление в storage новой переменной окружения

* `void putAll(Map<String, String> m)` – добавление нескольких ключей за раз. Нужно для случая, который описывается дальше.

Заметим, что есть еще некоторые системные переменные окружения, например `$HOME`, которые «заранее» присвоены в любой сессии работы терминала. Поэтому в `Memory` сначала нужно загрузить их.



## Main

В Main читаются входные строки и передаются в Executor.

## Executor

В Executor вызывается парсер, ему передается строка. Если команда одна, то она вызывется с переданными аргументами. Если несколько, то вывод текущей команды передается следующей по номеру команде в листе. Еслт переданная строка - это присваивание, то добавляем в мапу 

## Parser

У нас есть несколько важных случаев работы: 

1) В одинарных кавычках подстановка переменных не происходит
>`% echo '$HOME'`
> 
> `$HOME`

2) В двойных кавычках подставнока переменных происходит
> `% echo "$HOME"`
> 
> `/Users/xbreathoflife`

3) Если двойные кавычки внутри одинарных, то подстановка не произойдет
> `% echo '"$HOME"'`
> 
> `"$HOME"`

4) Если одинарные кавычки внутри двойных, то подстановка произойдет
> `% echo "'$HOME'"`
>
> `'/Users/xbreathoflife'`

Поэтому нам нужно разбить нашу строку на элементы, подстроки.

* Все, что внутри кавычек, является одним элементом. Например, `"''$HOME''"` или `'""$HOME""'`. Причем важно знать, для каких элементов должна быть выполнена подстановка переменной, а для каких - нет. В примере выше для первого элемента выполнится подстановка, а для второго - нет.

* (Так как экранирование пока не поддержано, то одна одинарная кавычка не может являться подстрокой)

* Пробел не является элементом.

* Пайп (`|`) является элементом.

В результате получаем список подстрок. Причем часть из них помечена, что в них подстановка не требуется, другие же помечены, что требуется. Будем подставлять, пока не получим такой список, в котором никому подстановка не требуется. Причем заметим, что если строка отмечена, что подстановка требуется, но в ней нету знака `$`, то можем считать, что не требуется.

Именем переменной при подстановки считается все от символа `$` до символов `'`, `$`, `"` или конец подстроки.

После соединяем полученные подстроки и отдаем парсеру, чтобы он разбил строку на команды. 

### Алгоритм работы Parser

1. Делим все на `tokens`: `'`, `"`, `|`, `($\w|$\(\w\s\))+` (V), `[\w\.]+\w` (A). Делится по пробелам, а также с помощью кавычек
2. Создаем синтаксическое дерево по грамматике

---------------------------------------

#### Грамматика

* `S` - стартовый литерал
* `D` - набор токенов из команд и ее аргументов, который мы должны выполнять
* `C` - неполный набор токенов из команд и ее аргументов
* `A` - команда или ее аргумент
* `V` - переменная
* `T` - текст, который мы выводим
* `U` - текст, в котором может быть подстановка

* `S -> S|S`
* `S -> S"U"S`
* `S -> S'T'S`
* `S -> C`
* `U -> U'U'U`
* `U -> U"U"U`
* `U -> C`
* `C -> DA`
* `C -> DV`
* `D -> DA`
* `D -> DV`
* `D -> eps`

---------------------------------------

3. Выполняем команды и подстановки с листов до корня дерева. Если у нас `V`, то мы делаем подстановку. Если у нас `C`, то выполняем комманду. Идем по дереву слева направо

## Tree

Создает синтаксическое дерево. Передается `Executer` для прохода по дереву

## Node

Вершина синтаксического дерева.

Типы: `C`, `A`, `V`

`void do()` -- делаем то, что должна делать вершина (только для типов `C`, `V`)

## Command

В Command вызываем нужную команду с полученными аргументами, возвращаем строку или пустое значение.



![Схема архитектуры](https://github.com/kot239/SD-spring-2022/blob/task-1/CLIArchitecture.png)
