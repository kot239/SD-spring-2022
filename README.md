# SD-spring-2022

## Task 1

Сделали:

* Гордеева Татьяна
* Обрядина Александра
* Тарабонда Герман


## Memory 

`Memory` – класс, созданный для хранения переменных окружения. В нем должно быть следующее поле: 

*  `Map<String, String> storage` – ключом является имя переменной окружения, а значением – ее значение

И следующие методы:

* `String get(String key)` – получение значение переменной по ключу.

* `void put(String key, String value)` – добавление в storage новой переменной окружения

* `void putAll(Map<String, String> m)` – добавление нескольких ключей за раз. Нужно для случая, который описывается дальше.

Заметим, что есть еще некоторые системные переменные окружения, например `$HOME`, которые «заранее» присвоены в любой сессии работы терминала. Поэтому в `Memory` сначала нужно загрузить их.



## Main

В Main читаются входные строки и передаются в Executor.

## Executor

В Executor вызывается парсер, ему передается строка. Если команда одна, то она вызывется с переданными аргументами. Если несколько, то вывод текущей команды передается следующей по номеру команде в листе. Еслт переданная строка - это присваивание, то добавляем в мапу 

## Parser

У нас есть несколько важных случаев работы: 

1) В одинарных кавычках подстановка переменных не происходит
```console
% echo '$HOME'
$HOME
```

2) В двойных кавычках подставнока переменных происходит
```console
% echo "$HOME"
/Users/xbreathoflife
```

3) Если двойные кавычки внутри одинарных, то подстановка не произойдет
```console
% echo '"$HOME"'
"$HOME"
```

4) Если одинарные кавычки внутри двойных, то подстановка произойдет
```console
% echo "'$HOME'"
'/Users/xbreathoflife'
```

Поэтому нам нужно разбить нашу строку на элементы, подстроки.

* Все, что внутри кавычек, является одним элементом. Например, `"''$HOME''"` или `'""$HOME""'`. Причем важно знать, для каких элементов должна быть выполнена подстановка переменной, а для каких - нет. В примере выше для первого элемента выполнится подстановка, а для второго - нет.

* (Так как экранирование пока не поддержано, то одна одинарная кавычка не может являться подстрокой)

* Пробел не является элементом.

* Пайп (`|`) является элементом.

В результате получаем список подстрок. Причем часть из них помечена, что в них подстановка не требуется, другие же помечены, что требуется. Будем подставлять, пока не получим такой список, в котором никому подстановка не требуется. Причем заметим, что если строка отмечена, что подстановка требуется, но в ней нету знака `$`, то можем считать, что не требуется.

Именем переменной при подстановки считается все от символа `$` до символов `'`, `$`, `"` или конец подстроки.

После соединяем полученные подстроки и отдаем парсеру, чтобы он разбил строку на команды. 

### Алгоритм работы Parser

1. Делим все на `tokens`: `'`, `"`, `|`, `($\w|$\(\w\s\))+` (V), `[\w\.]+\w` (A). Делится по пробелам, а также с помощью кавычек
2. Создаем синтаксическое дерево по грамматике

---------------------------------------

#### Грамматика

* `S` - стартовый литерал
* `D` - набор токенов из команд и ее аргументов, который мы должны выполнять
* `C` - неполный набор токенов из команд и ее аргументов
* `A` - команда или ее аргумент
* `V` - переменная
* `T` - текст, который мы выводим
* `U` - текст, в котором может быть подстановка

* `S -> S|S`
* `S -> S"U"S`
* `S -> S'T'S`
* `S -> C`
* `U -> U'U'U`
* `U -> U"U"U`
* `U -> C`
* `C -> DA`
* `C -> DV`
* `D -> DA`
* `D -> DV`
* `D -> eps`

---------------------------------------

3. Выполняем команды и подстановки с листов до корня дерева. Если у нас `V`, то мы делаем подстановку. Если у нас `C`, то выполняем комманду. Идем по дереву слева направо

## Tree

Создает синтаксическое дерево. Передается `Executer` для прохода по дереву

## Node

Вершина синтаксического дерева.

Типы: `C`, `A`, `V`

`void do()` -- делаем то, что должна делать вершина (только для типов `C`, `V`)

## Command

У нас есть общий интерфейс `AbstractCommand`, в котором есть следующие поля:

`String command` - имя комманды

`InputStream inputStream` - поток ввода, из него читаем

`OutputStream outputStream` - поток вывода, в него пишем

И следующие методы:

`ReturnCode execute()` - запрос на выполнения `command`. В зависимости от результата выполнения вернет `ReturnCode`, что все хорошо или плохо.

Команды, которые описаны далее, наследуются от этого интерфейса.

### CatCommand

Есть дополнительное поле:

`List<String> args`

Должно быть передано не более одного аргумента. Если один, то в поток вывода будет записано содержимое файла.

Если аргументов больше - ошибка.

Если аргументов нет, то содержимое `inputStream` будет записано  в `outputStream`.

### EchoCommand

Есть дополнительное поле:

`List<String> args`

Записывает в поток вывода переданные аргументы, разделенные пробелом.


### WcCommand

Есть дополнительное поле:

`List<String> args`

Выводит в поток вывода количество строк, слов и байт в файле для каждого переданного аргумента. Новая строка на каждый аргумент.

Если аргументов нет, то берет данные из потока чтения.

### PwdCommand

Нет аргументов.

Выводит путь к текущей директории в поток вывода.

### ExitCommand

Вызывает у основого класса метод `exit()`, тем самым завершая чтение команд в бесконечном цикле.

### OtherCommand

Есть дополнительное поле:

`List<String> args`

Вызывает внешнюю программу с переданными аргументами. Вывод записывается в поток вывода.


![Схема архитектуры](https://github.com/kot239/SD-spring-2022/blob/task-1/CLIArchitecture.png)
